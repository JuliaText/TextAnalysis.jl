<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documents · TextAnalysis</title><meta name="title" content="Documents · TextAnalysis"/><meta property="og:title" content="Documents · TextAnalysis"/><meta property="twitter:title" content="Documents · TextAnalysis"/><meta name="description" content="Documentation for TextAnalysis."/><meta property="og:description" content="Documentation for TextAnalysis."/><meta property="twitter:description" content="Documentation for TextAnalysis."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TextAnalysis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Documents</a><ul class="internal"><li><a class="tocitem" href="#Creating-Documents"><span>Creating Documents</span></a></li><li><a class="tocitem" href="#Basic-Functions-for-Working-with-Documents"><span>Basic Functions for Working with Documents</span></a></li><li><a class="tocitem" href="#Document-Metadata"><span>Document Metadata</span></a></li><li><a class="tocitem" href="#Preprocessing-Documents"><span>Preprocessing Documents</span></a></li></ul></li><li><a class="tocitem" href="../corpus/">Corpus</a></li><li><a class="tocitem" href="../features/">Features</a></li><li><a class="tocitem" href="../semantic/">Semantic Analysis</a></li><li><a class="tocitem" href="../classify/">Classifier</a></li><li><a class="tocitem" href="../example/">Extended Example</a></li><li><a class="tocitem" href="../evaluation_metrics/">Evaluation Metrics</a></li><li><a class="tocitem" href="../LM/">Statistical Language Model</a></li><li><a class="tocitem" href="../APIReference/">API References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documents</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documents</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaText/TextAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaText/TextAnalysis.jl/blob/master/docs/src/documents.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Creating-Documents"><a class="docs-heading-anchor" href="#Creating-Documents">Creating Documents</a><a id="Creating-Documents-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Documents" title="Permalink"></a></h2><p>The basic unit of text analysis is a document. The TextAnalysis package allows one to work with documents stored in a variety of formats:</p><ul><li><em>FileDocument</em> : A document represented using a plain text file on disk</li><li><em>StringDocument</em> : A document represented using a UTF8 String stored in RAM</li><li><em>TokenDocument</em> : A document represented as a sequence of UTF8 tokens</li><li><em>NGramDocument</em> : A document represented as a bag of n-grams, which are UTF8 n-grams that map to counts</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These formats represent a hierarchy: you can always move down the hierarchy, but can generally not move up the hierarchy. A <code>FileDocument</code> can easily become a <code>StringDocument</code>, but an <code>NGramDocument</code> cannot easily become a <code>FileDocument</code>.</p></div></div><p>Creating any of the four basic types of documents is very easy:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.StringDocument" href="#TextAnalysis.StringDocument"><code>TextAnalysis.StringDocument</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StringDocument(txt::AbstractString)</code></pre><p>Represents a document using a UTF8 String stored in RAM.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; str = &quot;To be or not to be...&quot;
&quot;To be or not to be...&quot;

julia&gt; sd = StringDocument(str)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: To be or not to be...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/cc7aac7ce43a28cedc4629f54a47b70e5198adc9/src/document.jl#L88-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.FileDocument" href="#TextAnalysis.FileDocument"><code>TextAnalysis.FileDocument</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FileDocument(pathname::AbstractString)</code></pre><p>Represents a document using a plain text file on disk.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pathname = &quot;/usr/share/dict/words&quot;
&quot;/usr/share/dict/words&quot;

julia&gt; fd = FileDocument(pathname)
A FileDocument
 * Language: Languages.English()
 * Title: /usr/share/dict/words
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: A A&#39;s AMD AMD&#39;s AOL AOL&#39;s Aachen Aachen&#39;s Aaliyah</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/cc7aac7ce43a28cedc4629f54a47b70e5198adc9/src/document.jl#L57-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.TokenDocument" href="#TextAnalysis.TokenDocument"><code>TextAnalysis.TokenDocument</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TokenDocument(txt::AbstractString)
TokenDocument(txt::AbstractString, dm::DocumentMetadata)
TokenDocument(tkns::Vector{T}) where T &lt;: AbstractString</code></pre><p>Represents a document as a sequence of UTF8 tokens.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_tokens = String[&quot;To&quot;, &quot;be&quot;, &quot;or&quot;, &quot;not&quot;, &quot;to&quot;, &quot;be...&quot;]
6-element Array{String,1}:
    &quot;To&quot;
    &quot;be&quot;
    &quot;or&quot;
    &quot;not&quot;
    &quot;to&quot;
    &quot;be...&quot;

julia&gt; td = TokenDocument(my_tokens)
A TokenDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/cc7aac7ce43a28cedc4629f54a47b70e5198adc9/src/document.jl#L115-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.NGramDocument" href="#TextAnalysis.NGramDocument"><code>TextAnalysis.NGramDocument</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NGramDocument(txt::AbstractString, n::Integer=1)
NGramDocument(txt::AbstractString, dm::DocumentMetadata, n::Integer=1)
NGramDocument(ng::Dict{T, Int}, n::Integer=1) where T &lt;: AbstractString</code></pre><p>Represents a document as a bag of n-grams, which are UTF8 n-grams and map to counts.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_ngrams = Dict{String, Int}(&quot;To&quot; =&gt; 1, &quot;be&quot; =&gt; 2,
                                     &quot;or&quot; =&gt; 1, &quot;not&quot; =&gt; 1,
                                     &quot;to&quot; =&gt; 1, &quot;be...&quot; =&gt; 1)
Dict{String,Int64} with 6 entries:
  &quot;or&quot;    =&gt; 1
  &quot;be...&quot; =&gt; 1
  &quot;not&quot;   =&gt; 1
  &quot;to&quot;    =&gt; 1
  &quot;To&quot;    =&gt; 1
  &quot;be&quot;    =&gt; 2

julia&gt; ngd = NGramDocument(my_ngrams)
A NGramDocument{AbstractString}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/cc7aac7ce43a28cedc4629f54a47b70e5198adc9/src/document.jl#L157-L185">source</a></section></article><p>An NGramDocument consisting of bigrams or any higher order representation <code>N</code> can be easily created by passing the parameter <code>N</code> to <code>NGramDocument</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; NGramDocument(&quot;To be or not to be ...&quot;, 2)</code><code class="nohighlight hljs ansi" style="display:block;">A NGramDocument{AbstractString}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code></pre><p>For every type of document except a <code>FileDocument</code>, you can also construct a new document by simply passing in a string of text:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: To be or not to be...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; td = TokenDocument(&quot;To be or not to be...&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A TokenDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ngd = NGramDocument(&quot;To be or not to be...&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A NGramDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code></pre><p>The system will automatically perform tokenization or n-gramization in order to produce the required data. Unfortunately, <code>FileDocument</code>&#39;s cannot be constructed this way because filenames are themselves strings. It would cause chaos if filenames were treated as the text contents of a document.</p><p>That said, there is one way around this restriction: you can use the generic <code>Document()</code> constructor function, which will guess at the type of the inputs and construct the appropriate type of document object:</p><pre><code class="language-julia hljs">julia&gt; Document(&quot;To be or not to be...&quot;)
A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: To be or not to be...
julia&gt; Document(&quot;/usr/share/dict/words&quot;)
A FileDocument
 * Language: Languages.English()
 * Title: /usr/share/dict/words
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: A A&#39;s AMD AMD&#39;s AOL AOL&#39;s Aachen Aachen&#39;s Aaliyah

julia&gt; Document(String[&quot;To&quot;, &quot;be&quot;, &quot;or&quot;, &quot;not&quot;, &quot;to&quot;, &quot;be...&quot;])
A TokenDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***

julia&gt; Document(Dict{String, Int}(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 3))
A NGramDocument{AbstractString}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code></pre><p>This constructor is very convenient for working in the REPL, but should be avoided in permanent code because, unlike the other constructors, the return type of the <code>Document</code> function cannot be known at compile-time.</p><h2 id="Basic-Functions-for-Working-with-Documents"><a class="docs-heading-anchor" href="#Basic-Functions-for-Working-with-Documents">Basic Functions for Working with Documents</a><a id="Basic-Functions-for-Working-with-Documents-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Functions-for-Working-with-Documents" title="Permalink"></a></h2><p>Once you&#39;ve created a document object, you can work with it in many ways. The most obvious thing is to access its text using the <code>text()</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; text(sd)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;To be or not to be...&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function works without warnings on <code>StringDocument</code>&#39;s and <code>FileDocument</code>&#39;s. For <code>TokenDocument</code>&#39;s it is not possible to know if the text can be reconstructed perfectly, so calling <code>text(TokenDocument(&quot;This is text&quot;))</code> will produce a warning message before returning an approximate reconstruction of the text as it existed before tokenization. It is entirely impossible to reconstruct the text of an <code>NGramDocument</code>, so <code>text(NGramDocument(&quot;This is text&quot;))</code> raises an error.</p></div></div><p>Instead of working with the text itself, you can work with the tokens or n-grams of a document using the <code>tokens()</code> and <code>ngrams()</code> functions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tokens(sd)</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{String}:
 &quot;To&quot;
 &quot;be&quot;
 &quot;or&quot;
 &quot;not&quot;
 &quot;to&quot;
 &quot;be&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ngrams(sd)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Int64} with 5 entries:
  &quot;or&quot;  =&gt; 1
  &quot;not&quot; =&gt; 1
  &quot;to&quot;  =&gt; 1
  &quot;To&quot;  =&gt; 1
  &quot;be&quot;  =&gt; 2</code></pre><p>By default the <code>ngrams()</code> function produces unigrams. If you would like to produce bigrams or trigrams, you can specify that directly using a numeric argument to the <code>ngrams()</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ngrams(sd, 2)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{AbstractString, Int64} with 5 entries:
  &quot;To be&quot;  =&gt; 1
  &quot;or not&quot; =&gt; 1
  &quot;be or&quot;  =&gt; 1
  &quot;not to&quot; =&gt; 1
  &quot;to be&quot;  =&gt; 1</code></pre><p>The <code>ngrams()</code> function can also be called with multiple arguments:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;To be or not to be...&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ngrams(sd, 2, 3)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{AbstractString, Int64} with 9 entries:
  &quot;To be&quot;     =&gt; 1
  &quot;or not&quot;    =&gt; 1
  &quot;be or&quot;     =&gt; 1
  &quot;be or not&quot; =&gt; 1
  &quot;or not to&quot; =&gt; 1
  &quot;not to&quot;    =&gt; 1
  &quot;to be&quot;     =&gt; 1
  &quot;not to be&quot; =&gt; 1
  &quot;To be or&quot;  =&gt; 1</code></pre><p>If you have a <code>NGramDocument</code>, you can determine whether an <code>NGramDocument</code> contains unigrams, bigrams or a higher-order representation using the <code>ngram_complexity()</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ngd = NGramDocument(&quot;To be or not to be ...&quot;, 2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ngram_complexity(ngd)</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><p>This information is not available for other types of <code>Document</code> objects because it is possible to produce any level of complexity when constructing n-grams from raw text or tokens.</p><h2 id="Document-Metadata"><a class="docs-heading-anchor" href="#Document-Metadata">Document Metadata</a><a id="Document-Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Document-Metadata" title="Permalink"></a></h2><p>In addition to methods for manipulating the representation of the text of a document, every document object also stores basic metadata about itself, including the following pieces of information:</p><ul><li><code>language()</code>: What language is the document in? Defaults to <code>Languages.English()</code>, a Language instance defined by the Languages package.</li><li><code>title()</code>: What is the title of the document? Defaults to <code>&quot;Untitled Document&quot;</code>.</li><li><code>author()</code>: Who wrote the document? Defaults to <code>&quot;Unknown Author&quot;</code>.</li><li><code>timestamp()</code>: When was the document written? Defaults to <code>&quot;Unknown Time&quot;</code>.</li></ul><p>Try these functions out on a <code>StringDocument</code> to see how the defaults work in practice:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;This document has too foo words&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: This document has too foo words</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; language(sd)</code><code class="nohighlight hljs ansi" style="display:block;">Languages.English()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; title(sd)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Untitled Document&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; author(sd)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Unknown Author&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; timestamp(sd)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Unknown Time&quot;</code></pre><p>If you need reset these fields, you can use the mutating versions of the same functions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis, Languages</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: Package Languages not found in current path.
- Run `import Pkg; Pkg.add(&quot;Languages&quot;)` to install the Languages package.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;This document has too foo words&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: This document has too foo words</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; language!(sd, Languages.Spanish())</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `Languages` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; title!(sd, &quot;El Cid&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;El Cid&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; author!(sd, &quot;Desconocido&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Desconocido&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; timestamp!(sd, &quot;Desconocido&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Desconocido&quot;</code></pre><h2 id="Preprocessing-Documents"><a class="docs-heading-anchor" href="#Preprocessing-Documents">Preprocessing Documents</a><a id="Preprocessing-Documents-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocessing-Documents" title="Permalink"></a></h2><p>Having easy access to the text of a document and its metadata is very important, but most text analysis tasks require some amount of preprocessing.</p><p>At a minimum, your text source may contain corrupt characters. You can remove these using the <code>remove_corrupt_utf8!()</code> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.remove_corrupt_utf8!" href="#TextAnalysis.remove_corrupt_utf8!"><code>TextAnalysis.remove_corrupt_utf8!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_corrupt_utf8!(doc)
remove_corrupt_utf8!(crps)</code></pre><p>Remove corrupt UTF8 characters for <code>doc</code> or documents in <code>crps</code>. Does not support <code>FileDocument</code> or Corpus containing <code>FileDocument</code>. See also: <a href="../APIReference/#TextAnalysis.remove_corrupt_utf8-Tuple{AbstractString}"><code>remove_corrupt_utf8</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/cc7aac7ce43a28cedc4629f54a47b70e5198adc9/src/preprocessing.jl#L50-L56">source</a></section></article><p>Alternatively, you may want to edit the text to remove items that are hard to process automatically. For example, our sample text sentence taken from Hamlet has three periods that we might like to discard. We can remove this kind of punctuation using the <code>prepare!()</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = StringDocument(&quot;here are some punctuations !!!...&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: here are some punctuations !!!...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prepare!(str, strip_punctuation)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; text(str)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;here are some punctuations &quot;</code></pre><ul><li>To remove case distinctions, use <code>remove_case!()</code> function:</li><li>At times you&#39;ll want to remove specific words from a document like a person&#39;s</li></ul><p>name. To do that, use the <code>remove_words!()</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;Lear is mad&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: Lear is mad</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; remove_case!(sd)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; text(sd)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;lear is mad&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; remove_words!(sd, [&quot;lear&quot;])</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; text(sd)</code><code class="nohighlight hljs ansi" style="display:block;">&quot; is mad&quot;</code></pre><p>At other times, you&#39;ll want to remove whole classes of words. To make this easier, we can use several classes of basic words defined by the Languages.jl package:</p><ul><li><em>Articles</em> : &quot;a&quot;, &quot;an&quot;, &quot;the&quot;</li><li><em>Indefinite Articles</em> : &quot;a&quot;, &quot;an&quot;</li><li><em>Definite Articles</em> : &quot;the&quot;</li><li><em>Prepositions</em> : &quot;across&quot;, &quot;around&quot;, &quot;before&quot;, ...</li><li><em>Pronouns</em> : &quot;I&quot;, &quot;you&quot;, &quot;he&quot;, &quot;she&quot;, ...</li><li><em>Stop Words</em> : &quot;all&quot;, &quot;almost&quot;, &quot;alone&quot;, ...</li></ul><p>These special classes can all be removed using specially-named parameters:</p><ul><li><code>prepare!(sd, strip_articles)</code></li><li><code>prepare!(sd, strip_indefinite_articles)</code></li><li><code>prepare!(sd, strip_definite_articles)</code></li><li><code>prepare!(sd, strip_prepositions)</code></li><li><code>prepare!(sd, strip_pronouns)</code></li><li><code>prepare!(sd, strip_stopwords)</code></li><li><code>prepare!(sd, strip_numbers)</code></li><li><code>prepare!(sd, strip_non_letters)</code></li><li><code>prepare!(sd, strip_sparse_terms)</code></li><li><code>prepare!(sd, strip_frequent_terms)</code></li><li><code>prepare!(sd, strip_html_tags)</code></li></ul><p>These functions use words lists, so they are capable of working for many different languages without change, also these operations can be combined together for improved performance:</p><ul><li><code>prepare!(sd, strip_articles| strip_numbers| strip_html_tags)</code></li></ul><p>In addition to removing words, it is also common to take words that are closely related like &quot;dog&quot; and &quot;dogs&quot; and stem them in order to produce a smaller set of words for analysis. We can do this using the <code>stem!()</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sd = StringDocument(&quot;They write, it writes&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">A StringDocument{String}
 * Language: Languages.English()
 * Title: Untitled Document
 * Author: Unknown Author
 * Timestamp: Unknown Time
 * Snippet: They write, it writes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stem!(sd)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; text(sd)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;They write , it write&quot;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../corpus/">Corpus »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 27 October 2023 23:39">Friday 27 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
