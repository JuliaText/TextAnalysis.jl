<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Features · TextAnalysis</title><meta name="title" content="Features · TextAnalysis"/><meta property="og:title" content="Features · TextAnalysis"/><meta property="twitter:title" content="Features · TextAnalysis"/><meta name="description" content="Documentation for TextAnalysis."/><meta property="og:description" content="Documentation for TextAnalysis."/><meta property="twitter:description" content="Documentation for TextAnalysis."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TextAnalysis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../documents/">Documents</a></li><li><a class="tocitem" href="../corpus/">Corpus</a></li><li class="is-active"><a class="tocitem" href>Features</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-Document-Term-Matrix"><span>Creating a Document Term Matrix</span></a></li><li><a class="tocitem" href="#Creating-Individual-Rows-of-a-Document-Term-Matrix"><span>Creating Individual Rows of a Document Term Matrix</span></a></li><li><a class="tocitem" href="#The-Hash-Trick"><span>The Hash Trick</span></a></li><li><a class="tocitem" href="#TF-(Term-Frequency)"><span>TF (Term Frequency)</span></a></li><li><a class="tocitem" href="#TF-IDF-(Term-Frequency-Inverse-Document-Frequency)"><span>TF-IDF (Term Frequency - Inverse Document Frequency)</span></a></li><li><a class="tocitem" href="#Okapi-BM-25"><span>Okapi BM-25</span></a></li><li><a class="tocitem" href="#Co-occurrence-matrix-(COOM)"><span>Co occurrence matrix (COOM)</span></a></li><li><a class="tocitem" href="#Summarizer"><span>Summarizer</span></a></li></ul></li><li><a class="tocitem" href="../semantic/">Semantic Analysis</a></li><li><a class="tocitem" href="../classify/">Classifier</a></li><li><a class="tocitem" href="../example/">Extended Example</a></li><li><a class="tocitem" href="../evaluation_metrics/">Evaluation Metrics</a></li><li><a class="tocitem" href="../LM/">Statistical Language Model</a></li><li><a class="tocitem" href="../APIReference/">API References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Features</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaText/TextAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaText/TextAnalysis.jl/blob/master/docs/src/features.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Creating-a-Document-Term-Matrix"><a class="docs-heading-anchor" href="#Creating-a-Document-Term-Matrix">Creating a Document Term Matrix</a><a id="Creating-a-Document-Term-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Document-Term-Matrix" title="Permalink"></a></h2><p>Often we want to represent documents as a matrix of word counts so that we can apply linear algebra operations and statistical techniques. Before we do this, we need to update the lexicon:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
                      StringDocument(&quot;To become or not to become&quot;)])</code><code class="nohighlight hljs ansi" style="display:block;">A Corpus with 2 documents:
 * 2 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; update_lexicon!(crps)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = DocumentTermMatrix(crps)</code><code class="nohighlight hljs ansi" style="display:block;">A 2 X 6 DocumentTermMatrix</code></pre><p>A <code>DocumentTermMatrix</code> object is a special type. If you would like to use a simple sparse matrix, call <code>dtm()</code> on this object:</p><pre><code class="language-julia hljs">julia&gt; dtm(m)
2×6 SparseArrays.SparseMatrixCSC{Int64,Int64} with 10 stored entries:
  [1, 1]  =  1
  [2, 1]  =  1
  [1, 2]  =  2
  [2, 3]  =  2
  [1, 4]  =  1
  [2, 4]  =  1
  [1, 5]  =  1
  [2, 5]  =  1
  [1, 6]  =  1
  [2, 6]  =  1</code></pre><p>If you would like to use a dense matrix instead, you can pass this as an argument to the <code>dtm</code> function:</p><pre><code class="language-julia hljs">julia&gt; dtm(m, :dense)
2×6 Array{Int64,2}:
 1  2  0  1  1  1
 1  0  2  1  1  1</code></pre><h2 id="Creating-Individual-Rows-of-a-Document-Term-Matrix"><a class="docs-heading-anchor" href="#Creating-Individual-Rows-of-a-Document-Term-Matrix">Creating Individual Rows of a Document Term Matrix</a><a id="Creating-Individual-Rows-of-a-Document-Term-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Individual-Rows-of-a-Document-Term-Matrix" title="Permalink"></a></h2><p>In many cases, we don&#39;t need the entire document term matrix at once: we can make do with just a single row. You can get this using the <code>dtv</code> function. Because individual&#39;s document do not have a lexicon associated with them, we have to pass in a lexicon as an additional argument:</p><pre><code class="language-julia hljs">julia&gt; dtv(crps[1], lexicon(crps))
1×6 Array{Int64,2}:
 1  2  0  1  1  1</code></pre><h2 id="The-Hash-Trick"><a class="docs-heading-anchor" href="#The-Hash-Trick">The Hash Trick</a><a id="The-Hash-Trick-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hash-Trick" title="Permalink"></a></h2><p>The need to create a lexicon before we can construct a document term matrix is often prohibitive. We can often employ a trick that has come to be called the &quot;Hash Trick&quot; in which we replace terms with their hashed valued using a hash function that outputs integers from 1 to N. To construct such a hash function, you can use the <code>TextHashFunction(N)</code> constructor:</p><pre><code class="language-julia hljs">julia&gt; h = TextHashFunction(10)
TextHashFunction(hash, 10)</code></pre><p>You can see how this function maps strings to numbers by calling the <code>index_hash</code> function:</p><pre><code class="language-julia hljs">julia&gt; index_hash(&quot;a&quot;, h)
8

julia&gt; index_hash(&quot;b&quot;, h)
7</code></pre><p>Using a text hash function, we can represent a document as a vector with N entries by calling the <code>hash_dtv</code> function:</p><pre><code class="language-julia hljs">julia&gt; hash_dtv(crps[1], h)
1×10 Array{Int64,2}:
 0  2  0  0  1  3  0  0  0  0</code></pre><p>This can be done for a corpus as a whole to construct a DTM without defining a lexicon in advance:</p><pre><code class="language-julia hljs">julia&gt; hash_dtm(crps, h)
2×10 Array{Int64,2}:
 0  2  0  0  1  3  0  0  0  0
 0  2  0  0  1  1  0  0  2  0</code></pre><p>Every corpus has a hash function built-in, so this function can be called using just one argument:</p><pre><code class="language-julia hljs">julia&gt; hash_dtm(crps)
2×100 Array{Int64,2}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  2  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0</code></pre><p>Moreover, if you do not specify a hash function for just one row of the hash DTM, a default hash function will be constructed for you:</p><pre><code class="language-julia hljs">julia&gt; hash_dtv(crps[1])
1×100 Array{Int64,2}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0</code></pre><h2 id="TF-(Term-Frequency)"><a class="docs-heading-anchor" href="#TF-(Term-Frequency)">TF (Term Frequency)</a><a id="TF-(Term-Frequency)-1"></a><a class="docs-heading-anchor-permalink" href="#TF-(Term-Frequency)" title="Permalink"></a></h2><p>Often we need to find out the proportion of a document is contributed by each term. This can be done by finding the term frequency function</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.tf" href="#TextAnalysis.tf"><code>TextAnalysis.tf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tf(dtm::DocumentTermMatrix)
tf(dtm::SparseMatrixCSC{Real})
tf(dtm::Matrix{Real})</code></pre><p>Compute the <code>term-frequency</code> of the input.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
              StringDocument(&quot;To become or not to become&quot;)])

julia&gt; update_lexicon!(crps)

julia&gt; m = DocumentTermMatrix(crps)

julia&gt; tf(m)
2×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 10 stored entries:
  [1, 1]  =  0.166667
  [2, 1]  =  0.166667
  [1, 2]  =  0.333333
  [2, 3]  =  0.333333
  [1, 4]  =  0.166667
  [2, 4]  =  0.166667
  [1, 5]  =  0.166667
  [2, 5]  =  0.166667
  [1, 6]  =  0.166667
  [2, 6]  =  0.166667</code></pre><p>See also: <a href="../APIReference/#TextAnalysis.tf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T}, SparseArrays.SparseMatrixCSC{F}}} where {T&lt;:Real, F&lt;:AbstractFloat}"><code>tf!</code></a>, <a href="#TextAnalysis.tf_idf"><code>tf_idf</code></a>, <a href="../APIReference/#TextAnalysis.tf_idf!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>tf_idf!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/d69315b39366adf53c48154725f2128416eb2d21/src/tf_idf.jl#L57-L89">source</a></section></article><p>The parameter, <code>dtm</code> can be of the types - <code>DocumentTermMatrix</code> , <code>SparseMatrixCSC</code> or <code>Matrix</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
                      StringDocument(&quot;To become or not to become&quot;)])</code><code class="nohighlight hljs ansi" style="display:block;">A Corpus with 2 documents:
 * 2 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; update_lexicon!(crps)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = DocumentTermMatrix(crps)</code><code class="nohighlight hljs ansi" style="display:block;">A 2 X 6 DocumentTermMatrix</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tf(m)</code><code class="nohighlight hljs ansi" style="display:block;">2×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 10 stored entries:
 0.166667  0.333333   ⋅        0.166667  0.166667  0.166667
 0.166667   ⋅        0.333333  0.166667  0.166667  0.166667</code></pre><h2 id="TF-IDF-(Term-Frequency-Inverse-Document-Frequency)"><a class="docs-heading-anchor" href="#TF-IDF-(Term-Frequency-Inverse-Document-Frequency)">TF-IDF (Term Frequency - Inverse Document Frequency)</a><a id="TF-IDF-(Term-Frequency-Inverse-Document-Frequency)-1"></a><a class="docs-heading-anchor-permalink" href="#TF-IDF-(Term-Frequency-Inverse-Document-Frequency)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.tf_idf" href="#TextAnalysis.tf_idf"><code>TextAnalysis.tf_idf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tf(dtm::DocumentTermMatrix)
tf(dtm::SparseMatrixCSC{Real})
tf(dtm::Matrix{Real})</code></pre><p>Compute <code>tf-idf</code> value (Term Frequency - Inverse Document Frequency) for the input.</p><p>In many cases, raw word counts are not appropriate for use because:</p><ul><li>Some documents are longer than other documents</li><li>Some words are more frequent than other words</li></ul><p>A simple workaround this can be done by performing <code>TF-IDF</code> on a <code>DocumentTermMatrix</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
              StringDocument(&quot;To become or not to become&quot;)])

julia&gt; update_lexicon!(crps)

julia&gt; m = DocumentTermMatrix(crps)

julia&gt; tf_idf(m)
2×6 SparseArrays.SparseMatrixCSC{Float64,Int64} with 10 stored entries:
  [1, 1]  =  0.0
  [2, 1]  =  0.0
  [1, 2]  =  0.231049
  [2, 3]  =  0.231049
  [1, 4]  =  0.0
  [2, 4]  =  0.0
  [1, 5]  =  0.0
  [2, 5]  =  0.0
  [1, 6]  =  0.0
  [2, 6]  =  0.0</code></pre><p>See also: <a href="../APIReference/#TextAnalysis.tf!-Union{Tuple{F}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T}, SparseArrays.SparseMatrixCSC{F}}} where {T&lt;:Real, F&lt;:AbstractFloat}"><code>tf!</code></a>, <a href="#TextAnalysis.tf_idf"><code>tf_idf</code></a>, <a href="../APIReference/#TextAnalysis.tf_idf!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>tf_idf!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/d69315b39366adf53c48154725f2128416eb2d21/src/tf_idf.jl#L172-L211">source</a></section></article><p>In many cases, raw word counts are not appropriate for use because:</p><ul><li>(A) Some documents are longer than other documents</li><li>(B) Some words are more frequent than other words</li></ul><p>You can work around this by performing TF-IDF on a DocumentTermMatrix:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; crps = Corpus([StringDocument(&quot;To be or not to be&quot;),
                      StringDocument(&quot;To become or not to become&quot;)])</code><code class="nohighlight hljs ansi" style="display:block;">A Corpus with 2 documents:
 * 2 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; update_lexicon!(crps)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = DocumentTermMatrix(crps)</code><code class="nohighlight hljs ansi" style="display:block;">A 2 X 6 DocumentTermMatrix</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tf_idf(m)</code><code class="nohighlight hljs ansi" style="display:block;">2×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 10 stored entries:
 0.0  0.231049   ⋅        0.0  0.0  0.0
 0.0   ⋅        0.231049  0.0  0.0  0.0</code></pre><p>As you can see, TF-IDF has the effect of inserting 0&#39;s into the columns of words that occur in all documents. This is a useful way to avoid having to remove those words during preprocessing.</p><h2 id="Okapi-BM-25"><a class="docs-heading-anchor" href="#Okapi-BM-25">Okapi BM-25</a><a id="Okapi-BM-25-1"></a><a class="docs-heading-anchor-permalink" href="#Okapi-BM-25" title="Permalink"></a></h2><p>From the document term matparamterix, <a href="https://en.wikipedia.org/wiki/Okapi_BM25">Okapi BM25</a> document-word statistic can be created.</p><pre><code class="nohighlight hljs">bm_25(dtm::AbstractMatrix; κ, β)
bm_25(dtm::DocumentTermMatrixm, κ, β)</code></pre><p>It can also be used via the following methods Overwrite the <code>bm25</code> with calculated weights.</p><pre><code class="nohighlight hljs">bm_25!(dtm, bm25, κ, β)</code></pre><p>The inputs matrices can also be a <code>Sparse Matrix</code>. The parameters κ and β default to 2 and 0.75 respectively.</p><p>Here is an example usage -</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; crps = Corpus([
         StringDocument(&quot;a a a sample text text&quot;),
         StringDocument(&quot;another example example text text&quot;),
         StringDocument(&quot;&quot;),
         StringDocument(&quot;another another text text text text&quot;)
       ])</code><code class="nohighlight hljs ansi" style="display:block;">A Corpus with 4 documents:
 * 4 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; update_lexicon!(crps)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = DocumentTermMatrix(crps)</code><code class="nohighlight hljs ansi" style="display:block;">A 4 X 5 DocumentTermMatrix</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bm_25(m)</code><code class="nohighlight hljs ansi" style="display:block;">4×5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
 1.29959   ⋅         ⋅       1.89031  0.405067
  ⋅       0.882404  1.54025   ⋅       0.405067
  ⋅        ⋅         ⋅        ⋅        ⋅
  ⋅       1.40179    ⋅        ⋅       0.676646</code></pre><h2 id="Co-occurrence-matrix-(COOM)"><a class="docs-heading-anchor" href="#Co-occurrence-matrix-(COOM)">Co occurrence matrix (COOM)</a><a id="Co-occurrence-matrix-(COOM)-1"></a><a class="docs-heading-anchor-permalink" href="#Co-occurrence-matrix-(COOM)" title="Permalink"></a></h2><p>The elements of the Co occurrence matrix indicate how many times two words co-occur in a (sliding) word window of a given size. The COOM can be calculated for objects of type <code>Corpus</code>, <code>AbstractDocument</code> (with the exception of <code>NGramDocument</code>).</p><pre><code class="nohighlight hljs">CooMatrix(crps; window, normalize)
CooMatrix(doc; window, normalize)</code></pre><p>It takes following keyword arguments:</p><ul><li><code>window::Integer</code> -length of the Window size, defaults to <code>5</code>. The actual size of the sliding window is 2 * window + 1, with the keyword argument window specifying how many words to consider to the left and right of the center one</li><li><code>normalize::Bool</code> -normalizes counts to distance between words, defaults to <code>true</code></li></ul><p>It returns the <code>CooMatrix</code> structure from which the matrix can be extracted using <code>coom(::CooMatrix)</code>. The <code>terms</code> can also be extracted from this. Here is an example usage -</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TextAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; crps = Corpus([StringDocument(&quot;this is a string document&quot;)])</code><code class="nohighlight hljs ansi" style="display:block;">A Corpus with 1 documents:
 * 1 StringDocument&#39;s
 * 0 FileDocument&#39;s
 * 0 TokenDocument&#39;s
 * 0 NGramDocument&#39;s

Corpus&#39;s lexicon contains 0 tokens
Corpus&#39;s index contains 0 tokens</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = CooMatrix(crps, window=1, normalize=false)</code><code class="nohighlight hljs ansi" style="display:block;">CooMatrix{Float64}(sparse([2, 5, 1, 4, 3, 5, 1, 4], [1, 1, 2, 3, 4, 4, 5, 5], [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], 5, 5), [&quot;string&quot;, &quot;document&quot;, &quot;this&quot;, &quot;is&quot;, &quot;a&quot;], OrderedCollections.OrderedDict(&quot;string&quot; =&gt; 1, &quot;document&quot; =&gt; 2, &quot;this&quot; =&gt; 3, &quot;is&quot; =&gt; 4, &quot;a&quot; =&gt; 5))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; coom(C)</code><code class="nohighlight hljs ansi" style="display:block;">5×5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  ⋅   2.0   ⋅    ⋅   2.0
 2.0   ⋅    ⋅    ⋅    ⋅
  ⋅    ⋅    ⋅   2.0   ⋅
  ⋅    ⋅   2.0   ⋅   2.0
 2.0   ⋅    ⋅   2.0   ⋅</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C.terms</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{String}:
 &quot;string&quot;
 &quot;document&quot;
 &quot;this&quot;
 &quot;is&quot;
 &quot;a&quot;</code></pre><p>It can also be called to calculate the terms for a specific list of words / terms in the document. In other cases it calculates the the co occurrence elements for all the terms.</p><pre><code class="nohighlight hljs">CooMatrix(crps, terms; window, normalize)
CooMatrix(doc, terms; window, normalize)</code></pre><pre><code class="language-julia hljs">julia&gt; C = CooMatrix(crps, [&quot;this&quot;, &quot;is&quot;, &quot;a&quot;], window=1, normalize=false)
CooMatrix{Float64}(
  [2, 1]  =  4.0
  [1, 2]  =  4.0
  [3, 2]  =  4.0
  [2, 3]  =  4.0, [&quot;this&quot;, &quot;is&quot;, &quot;a&quot;], OrderedCollections.OrderedDict(&quot;this&quot;=&gt;1,&quot;is&quot;=&gt;2,&quot;a&quot;=&gt;3))
</code></pre><p>The type can also be specified for <code>CooMatrix</code> with the weights of type <code>T</code>. <code>T</code> defaults to <code>Float64</code>.</p><pre><code class="nohighlight hljs">CooMatrix{T}(crps; window, normalize) where T &lt;: AbstractFloat
CooMatrix{T}(doc; window, normalize) where T &lt;: AbstractFloat
CooMatrix{T}(crps, terms; window, normalize) where T &lt;: AbstractFloat
CooMatrix{T}(doc, terms; window, normalize) where T &lt;: AbstractFloat</code></pre><p>Remarks:</p><ul><li>The sliding window used to count co-occurrences does not take into consideration sentence stops however, it does with documents i.e. does not span across documents</li><li>The co-occurrence matrices of the documents in a corpus are summed up when calculating the matrix for an entire corpus</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Co occurrence matrix does not work for <code>NGramDocument</code>, or a Corpus containing an <code>NGramDocument</code>.</p></div></div><pre><code class="language-julia hljs">julia&gt; C = CooMatrix(NGramDocument(&quot;A document&quot;), window=1, normalize=false) # fails, documents are NGramDocument
ERROR: The tokens of an NGramDocument cannot be reconstructed</code></pre><h2 id="Summarizer"><a class="docs-heading-anchor" href="#Summarizer">Summarizer</a><a id="Summarizer-1"></a><a class="docs-heading-anchor-permalink" href="#Summarizer" title="Permalink"></a></h2><p>TextAnalysis offers a simple text-rank based summarizer for its various document types.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TextAnalysis.summarize" href="#TextAnalysis.summarize"><code>TextAnalysis.summarize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">summarize(doc [, ns])</code></pre><p>Summarizes the document and returns <code>ns</code> number of sentences. It takes 2 arguments:</p><ul><li><code>d</code> : A document of type <code>StringDocument</code>, <code>FileDocument</code> or <code>TokenDocument</code></li><li><code>ns</code> : (Optional) Mention the number of sentences in the Summary, defaults to <code>5</code> sentences.</li></ul><p>By default <code>ns</code> is set to the value 5.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = StringDocument(&quot;Assume this Short Document as an example. Assume this as an example summarizer. This has too foo sentences.&quot;)

julia&gt; summarize(s, ns=2)
2-element Array{SubString{String},1}:
 &quot;Assume this Short Document as an example.&quot;
 &quot;This has too foo sentences.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaText/TextAnalysis.jl/blob/d69315b39366adf53c48154725f2128416eb2d21/src/summarizer.jl#L1-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../corpus/">« Corpus</a><a class="docs-footer-nextpage" href="../semantic/">Semantic Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 6 September 2024 16:09">Friday 6 September 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
